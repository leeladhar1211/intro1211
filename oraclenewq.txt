A candidate key is a column, or set of columns, in a table that can uniquely identify any database record without referring to any other data. Each table may have one or more candidate keys, but one candidate key is unique, and it is called the primary key
Candidate Key – A Candidate Key can be any column or a combination of columns that can qualify as unique key in database. There can be multiple Candidate Keys in one table. Each Candidate Key can qualify as Primary Key. Primary Key – A Primary Key is a column or a combination of columns that uniquely identify a record.
Dense Index:The index structure will have presence of each and every index key. This corresponds to option 1.
Sparse Index:The index structure will have presence of one index entry per data block. This index entry will be the one that points to the first record/row in the data block. This is option 2.
A Clustered Index is the table itself, and while creating it, it re-orders the table with the Clustering Key. Thus you can have only one Clustered Index on a table.
A Non-Clustered Index is a copy of the table with selected columns.
Clustered indexes are usually used for your primary key and that non-clustered are used for other situations.
Primary Index − Primary index is defined on an ordered data file. The data file is ordered on a key field. The key field is generally the primary key of the relation.
Secondary Index − Secondary index may be generated from a field which is a candidate key and has a unique value in every record, or a non-key with duplicate values.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Differences between CAST and CONVERT
CAST is part of the ANSI-SQL specification; whereas, CONVERT is not.  In fact, CONVERT is SQL implementation specific.

CONVERT differences lie in that it accepts an optional style parameter which is used for formatting.

For example, when converting a DateTime datatype to Varchar, you can specify the resulting date’s format, such as YYYY/MM/DD or MM/DD/YYYY.

SELECT CONVERT(VARCHAR,GETDATE(),101) as MMDDYYYY,
       CONVERT(VARCHAR,GETDATE(),111) as YYYYMMDD
	   
Using CAST:
CAST ( expression AS data_type )

Using CONVERT:
CONVERT ( data_type [ ( length ) ] , expression [ , style ] )


 Can you write a query to find employees with age greater than 30? 
 DATEDIFF (datepart ,startdate ,enddate) --syntax
select * from employee  
where datediff(year,dob, getdate()) >30 

Can you show one row twice in results from a table?
select deptname from department d where d.deptname='it'  
union all  
select deptname from department d1 where d1.deptname='it' 

Could you tell the output or result of the following SQL statements? 
Answer 
select '7'  
-- output = 7  
select 7  
-- output = 7  
select count (7)  
-- output = 1  
SELECT COUNT('7')  
-- output = 1  
SELECT COUNT(*)  
 -- output = 1  
 
 Will the following statements  run or give error?
Answer

NO error. 
SELECT COUNT(*) + COUNT(*)  
Output  = 2  
SELECT (SELECT 'c#')  
Output = c#  

Can you write a query to get employee names starting with a vowel?
Answer 
  
Using like operator and expression, 
Select empid, empname from employee where empname like '[aeiou]%'

What will be the output of following SQL?(tricky)  
Select $    
  
Options  -   
a. 0.00,   
b. $,  
c. 0,  
d. Syntax Error  
  
Answer  = 0.00 

SELECT SUM (1+4*5)  
  
Options - a.21,      b.25,         c.Error        d.10   
  
Answer -: 21  
  
  
SELECT MAX  (1,3,8)  
  
Options - a.8,        b. 12,        c.Error        d.1   
  
Answer -: Error. Max function takes only 1 argument.  
  
  
SELECT Max ('TD')  
  
Options -  a.TD         b. Error      c. 1       d.0  
  
Answer-: TD  
  
  
SELECT Max ('TD'+'AD')  
  
Options -  a.TDAD         b. Error      c. T2D       d.0  
Answer-: TDAD 

SELECT 0/0  
  
A. Divide by 0 error,   B. 0  
C. NULL,                   D. Incorrect syntax error  
  
Answer -:  Divide by 0 error  
  
SELECT  0/6  
  
A. Divide by 0 error,   B. 0  
C. 6,                         D. Incorrect syntax error  
  
Answer -:  0  

SELECT SUM (NULL) or avg(null)
Answer = Error. Operand data type NULL is invalid for MAX operator.

Will the following statements execute? if yes what will be output?

SELECT NULL+1
SELECT NULL+'1'

Answer - Yes, no error. The output will be NULL. Perform any operation on NULL will get the NULL result.

Will following statement give Divide by Zero error?

SELECT NULL/0

Answer- No. It will execute and result will be NULL.
 
 --------------------------------------------------------------------------------------------------------------------------

Given a table TBL with a field Nmbr that has rows with the following values:

1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1

Write a query to add 2 where Nmbr is 0 and add 3 where Nmbr is 1.

update TBL set Nmbr = case when Nmbr = 0 then Nmbr+2 else Nmbr+3 end;
---------------------------------------------------------------------------------------------
Table is as follows:

ID	C1	C2	C3
1	Red	Yellow	Blue
2	NULL	Red	Green
3	Yellow	NULL	Violet
Print the rows which have ‘Yellow’ in one of the columns C1, C2, or C3, but without using OR.

SELECT * FROM table
WHERE 'Yellow' IN (C1, C2, C3)
--------------------------------------------------------------------------------------------------
Write a query to insert/update Col2’s values to look exactly opposite to Col1’s values.

Col1	Col2
1	0
0	1
0	1
0	1
1	0
0	1
1	0
1	0

update table set col2 = case when col1 = 1 then 0 else 1 end
--------------------------------------------------------------------------------------------------------
Imagine a single column in a table that is populated with either a single digit (0-9) or a single character (a-z, A-Z). Write a SQL query to print ‘Fizz’ for a numeric value or ‘Buzz’ for alphabetical value for all values in that column.

Example:

['d', 'x', 'T', 8, 'a', 9, 6, 2, 'V']

…should output:

['Buzz', 'Buzz', 'Buzz', 'Fizz', 'Buzz','Fizz', 'Fizz', 'Fizz', 'Buzz']

SELECT col, case when upper(col) = lower(col) then 'Fizz' else 'Buzz' end as FizzBuzz from table;
------------------------------------------------------------------------------------------------------------
Given the following table named A:

  x
------
  2
 -2
  4
 -4
 -3    
  0
  2
Write a single query to calculate the sum of all positive values of x and he sum of all negative values of x.

select sum(case when x>0 then x else 0 end)sum_pos,sum(case when x<0 then x else 0 end)sum_neg from a;
--------------------------------------------------------------------------------------------------------------
Given the table mass_table:

weight
5.67
34.567
365.253
34
Write a query that produces the output:

weight	kg	gms
5.67	5	67
34.567	34	567
365.253	365	253
34	34	0

select weight, trunc(weight) as kg, nvl(substr(weight - trunc(weight), 2), 0) as gms
from mass_table;
----------------------------------------------------------------------------------------------------------------------
Consider the Employee table below.

Emp_Id	Emp_name	Salary	Manager_Id
10	Anil	50000	18
11	Vikas	75000	16
12	Nisha	40000	18
13	Nidhi	60000	17
14	Priya	80000	18
15	Mohit	45000	18
16	Rajesh	90000	–
17	Raman	55000	16
18	Santosh	65000	17
Write a query to generate below output:

Manager_Id	Manager	Average_Salary_Under_Manager
16	Rajesh	65000
17	Raman	62500
18	Santosh	53750

select b.emp_id as "Manager_Id",
          b.emp_name as "Manager", 
          avg(a.salary) as "Average_Salary_Under_Manager"
from Employee a, 
     Employee b
where a.manager_id = b.emp_id
group by b.emp_id, b.emp_name
order by b.emp_id;
-----------------------------------------------------------------------------
How to display 1 to 100 Numbers with query?
Select level from dual connect by level <=100;

How to Show the Max marks and min marks together from student table?
Select max (marks) from Student

Union

Select min (marks) from Student;

How to display Date in DD-MON-YYYY table?
Select to_date (Hire_date,’DD-MON-YYYY’) Date_Format from Employee;

If marks column contain the comma separated values from Student table. How to calculate the count of that comma separated values?

Student Name	Marks
Amit	30,130,20,4
Sukruta	100,20,30
Sonali	140,10

want to display thr output like this
Student Name	Marks Count
Amit	4
Sukruta	3
Sonali	2

Select Student_name, regexp_count (marks,’,’) + As “Marks Count” from Student;

---------------------------------------------------------------------------------------------

How to get DDL of table in Oracle?

Select dbms_metadata.get_ddl (TABLE,’table_name’) from dual;
----------------------------------------------------------------------------------
Write query to find the repeated characters from your name?

Select regexp_count (‘AmitA’,’A’) as Repeated_character from dual;
---------------------------------------------------------------------------------
What is query to fetch last day of previous month in oracle?

Select LAST_DAY (ADD_MONTHS (SYSDATE,-1)) from dual;

to drop all tables  Execute immediate (‘Drop Table  ‘||i.table_name||’cascade constraints’);

Sample Input

Table11

Id
1
2
3
4
Table12

Id
101
102
103
104
105
106

output
Id	RandomValue
1	106
2	105
3	103
4	101

SELECT x.Id, y.Id RandomValue FROM
(
    SELECT * , ROW_NUMBER() OVER (ORDER BY NEWID()) rnk FROM Table11 a
)x 
INNER JOIN
(
    SELECT * , ROW_NUMBER() OVER (ORDER BY NEWID()) rnk FROM Table12 a
)y ON x.rnk = y.rnk
 -------------------------------------------------------------------------------------
 
The FROM/WHERE clause goes first.
ROWNUM is assigned and incremented to each output row from the FROM/WHERE clause.
SELECT is applied.
GROUP BY is applied.
HAVING is applied.
ORDER BY is applied.
--------------------------------------------------------------
delete from emp where dept_id =
(select dept_id from dept where dept_name like '%public%'); --deleting rows based on another table
---------------------------------------------------------------------------------------------------------------
comment on table emp is 'emp information';  -- comments can be viewed through (All_TAB_comments,user_tab_comments)
---------------------------------------------------------------------------------------------------------------------
oracle tables
ALL_COL_COMMENTS	--Comments on columns of accessible tables and views
ALL_CONSTRAINTS	    --Constraint definitions on accessible tables
ALL_DB_LINKS	    --Database links accessible to the user
ALL_ERRORS	        --Current errors on stored objects that user is allowed to create
ALL_INDEXES	        --Descriptions of indexes on tables accessible to the user
ALL_OBJECTS	        --Objects accessible to the user
ALL_OBJECT_TABLES	--Description of all object tables accessible to the user
ALL_TRIGGERS	    --Triggers accessible to the current user
DBA_DB_LINKS	    --All database links in the database
DBA_ROLE_PRIVS	    --Roles granted to users and roles
--------------------------------------------------------------------------------------------------------------------------------
SELECT REGEXP_COUNT ('TechOnTheNet is a great resource', 't')
FROM dual;
Result: 2
----------------------------------------------------------------------------------------------------------------------------------
 Select Employee_name,Salary/12 as ‘Monthly Salary’ from employee; --monthly salary of an emplyee if annual salary is given
 Select * from Employee where Rownum =1; -- 1 st record from emp
 Select * from Employee where Rowid= select max(Rowid) from Employee; --last record from emp table 
 Select * from Employee  where rownum = &n;  -- to display Nth Record from Employee table
 Create table Employee_1 as Select * from Employee where 1=2;      --Can i create table with same structure of Employee table
 Select rownum,E.* from Employee E where rownum<=(Select count(*/2) from Employee); --selecting 50% records
 Select * from Employee;
 Intersect
 Select * from Employee1;    ---common records
 
 21.how to write sql query for the below scenario
I/p:ORACLE

O/p:
O
R
A
C
L
E
i.e, splitting into multiple columns a string using sql.

Answer:

Select Substr(‘ORACLE’,Level,1) From Dual
Connect By Level<= Length(‘ORACLE’);
------------------------------------------------------------------------------------------------------------------------------------
select * from Employee where To_char(Joining_date,’YYYY’)=’2017′; --fetching records who joined on 2017

Write an SQL Query find number of employees according to gender  whose DOB is between 01/01/1960 to 31/12/1975.
SELECT COUNT(*), sex from Employees WHERE DOB BETWEEN '01/01/1960' AND '31/12/1975' Group by sex

--------------------------------------------------------------------------------------------------------------------------------------
--hierarchical queries
Using hierarchical queries, you can retrieve records from a table by their natural relationship. Be it a family tree or a employee/manager tree or what ever.

Tree walking enables you to construct a hierarchical tree if the relationship lie in the same table. For instance, a manager column which exists in the emp table which defines the managerial hierarchy. 
CONNECT BY specifies the relationship between parent rows and child rows of the hierarchy.

SELECT last_name, employee_id, manager_id, LEVEL
      FROM employees
      START WITH employee_id = 100
      CONNECT BY PRIOR employee_id = manager_id
      ORDER SIBLINGS BY last_name;

LAST_NAME                 EMPLOYEE_ID MANAGER_ID      LEVEL
------------------------- ----------- ---------- ----------
King                              100                     1
Cambrault                         148        100          2
Bates                             172        148          3
Bloom                             169        148          3
Fox                               170        148          3
Kumar                             173        148          3
Ozer                              168        148          3
Smith                             171        148          3
De Haan                           102        100          2
Hunold                            103        102          3
Austin                            105        103          4
Ernst                             104        103          4
Lorentz                           107        103          4
Pataballa                         106        103          4
Errazuriz                         147        100          2
Ande                              166        147          3
Banda                             167        147          3

Query to get the product of all the values of a column :

SELECT EXP(SUM(LN(col1))) FROM srinu;
------------------------------------------------------------------------------------------------------------------------------------------
hi everyone , 
its a trick to copy the structure of the table wthout the
data . 
1 SQL> create table employee1 
2 as select * from emp
3 where 1=2;

the compiler will look for the statment 2 first 
then it will come to the 3 line to check the condition ,when
it gets a 0 [means false] at that time only the table
structure was there in the buffer ; now it will return to
the 1st statement to create a table with the structure only .
so it will return only the structure of the table . 
similarly when this 
SELET * 
FROM EMP 
WHERE 1=2;
querry is executed as per the false conditon it will only
show no rows selected . 
------------------------------------------------------------------------------------------------------------

SELECT *
FROM   (SELECT product_code, quantity
        FROM   pivot_test)
PIVOT  (SUM(quantity) AS sum_quantity FOR (product_code) IN ('A' AS a, 'B' AS b, 'C' AS c));

A_SUM_QUANTITY B_SUM_QUANTITY C_SUM_QUANTITY
-------------- -------------- --------------
           210             90            160

1 row selected.

SELECT *
FROM   (SELECT customer_id, product_code, quantity
        FROM   pivot_test)
PIVOT  (SUM(quantity) AS sum_quantity FOR (product_code) IN ('A' AS a, 'B' AS b, 'C' AS c))
ORDER BY customer_id;

CUSTOMER_ID A_SUM_QUANTITY B_SUM_QUANTITY C_SUM_QUANTITY
----------- -------------- -------------- --------------
          1             10             20             30
          2             40                            50
          3             60             70             80
          4            100

4 rows selected.

SELECT customer_id,
       SUM(DECODE(product_code, 'A', quantity, 0)) AS a_sum_quantity,
       SUM(DECODE(product_code, 'B', quantity, 0)) AS b_sum_quantity,
       SUM(DECODE(product_code, 'C', quantity, 0)) AS c_sum_quantity
FROM   pivot_test
GROUP BY customer_id
ORDER BY customer_id;

CUSTOMER_ID A_SUM_QUANTITY B_SUM_QUANTITY C_SUM_QUANTITY
----------- -------------- -------------- --------------
          1             10             20             30
          2             40              0             50
          3             60             70             80
          4            100              0              0

4 rows selected.

SELECT *
FROM   unpivot_test
UNPIVOT (quantity FOR product_code IN (product_code_a AS 'A', product_code_b AS 'B', product_code_c AS 'C', product_code_d AS 'D'));

        ID CUSTOMER_ID P   QUANTITY
---------- ----------- - ----------
         1         101 A         10
         1         101 B         20
         1         101 C         30
         2         102 A         40
         2         102 C         50
         3         103 A         60
         3         103 B         70
         3         103 C         80
         3         103 D         90
         4         104 A        100

10 rows selected.


There are several things to note about the query:

The required column names, in this case QUANTITY and PRODUCT_CODE, are define in the UNPIVOT clause. These can be set to any name not currently in the driving table.
The columns to be unpivoted must be named in the IN clause.
The PRODUCT_CODE value will match the column name it is derived from, unless you alias it to another value.
By default the EXCLUDE NULLS clause is used. To override the default behaviour use the INCLUDE NULLS clause.

SELECT id,
       customer_id,
       DECODE(unpivot_row, 1, 'A',
                           2, 'B',
                           3, 'C',
                           4, 'D',
                           'N/A') AS product_code,
       DECODE(unpivot_row, 1, product_code_a,
                           2, product_code_b,
                           3, product_code_c,
                           4, product_code_d,
                           'N/A') AS quantity
FROM   unpivot_test,
       (SELECT level AS unpivot_row FROM dual CONNECT BY level <= 4)
ORDER BY 1,2,3;

        ID CUSTOMER_ID PRO   QUANTITY
---------- ----------- --- ----------
         1         101 A           10
         1         101 B           20
         1         101 C           30
         1         101 D
         2         102 A           40
         2         102 B
         2         102 C           50
         2         102 D
         3         103 A           60
         3         103 B           70
         3         103 C           80

        ID CUSTOMER_ID PRO   QUANTITY
---------- ----------- --- ----------
         3         103 D           90
         4         104 A          100
         4         104 B
         4         104 C
         4         104 D

16 rows selected.


Use SQL within group for moving rows onto one line and listagg to display multiple column values in a single column

select deptno, listagg (ename, ',') 
WITHIN GROUP 
(ORDER BY ename) enames
FROM emp
GROUP BY deptno

    DEPTNO ENAMES                                            
---------- --------------------------------------------------
        10 CLARK,KING,MILLER                                 
        20 ADAMS,FORD,JONES,SCOTT,SMITH                
        30 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD     

•	Use the Oracle analytic Lag-Over Function

SELECT ename,hiredate,sal,LAG (sal, 1, 0)   
   OVER (ORDER BY hiredate) AS PrevSal
FROM emp
WHERE job = 'CLERK';

The Oracle/PLSQL LAG function is an analytic function that lets you query more than one row in a table at a time without having to join the table to itself. It returns values from a previous row in the table. To return a value from the next row, try using the LEAD function.

Syntax:

LAG ( expression [, offset [, default] ] )
OVER ( [ query_partition_clause ] order_by_clause )

-----------------------------------------------------------------

---sales on products query

0
down vote
favorite
I have a table which is like this.

id date       subtotal type
1 |2017-12-12 | 50.00 | 1
2 |2017-12-12 | 20.00 | 2
3 |2017-11-12 | 30.00 | 2
4 |2017-11-12 | 40.00 | 1
5 |2017-10-12 | 70.00 | 1
6 |2017-10-12 | 250.00| 2
In that case the type column presents sales (1) and buys(2). What I want to do is, group by this orders by month and get the total sale and buys at this month. Something like this.

id date        sale     buy
1 |December   | 50.00 | 20.00
2 |November   | 30.00 | 40.00
3 |October    | 70.00 | 250.00

select to_char(date,'Mon') as Month,
       extract(year from date) as Year,
       sum(case when type = 1 then subtotal else 0 end) as sales,
       sum(case when type = 2 then subtotal else 0 end) as buys
from table
group by Month, Year;

-- in a project i work at the moment we need to get monthly, quarterly and yearly sums of customer sales. i tried a query shown below which gets correct results for today. but i need to results for last years sale also. (last years monthly sale is that months sum)

This may help be what you want... it gives you totals for every month and quarter, and for the entire year, for every year. I would recommend adding a "where EXTRACT(YEAR FROM DAY) = 2012" or similar clause if you want a particular year.

I believe this is what you asked for, but that is different than the sample you provided. The sample you gave provided trailing 3, 6, 9, and 12 month sales, which is not the same as quarters years and months. Still, you could easily mix and match if needed.

SELECT    
CUSTOMER,        
PRODUCT,
EXTRACT(YEAR FROM DAY) YEAR,
SUM(DAILY_SALE) as YEAR_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '01' THEN DAILY_SALE ELSE 0 END) AS MONTH_01_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '02' THEN DAILY_SALE ELSE 0 END) AS MONTH_02_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '03' THEN DAILY_SALE ELSE 0 END) AS MONTH_03_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '04' THEN DAILY_SALE ELSE 0 END) AS MONTH_04_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '05' THEN DAILY_SALE ELSE 0 END) AS MONTH_05_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '06' THEN DAILY_SALE ELSE 0 END) AS MONTH_06_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '07' THEN DAILY_SALE ELSE 0 END) AS MONTH_07_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '08' THEN DAILY_SALE ELSE 0 END) AS MONTH_08_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '09' THEN DAILY_SALE ELSE 0 END) AS MONTH_09_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '10' THEN DAILY_SALE ELSE 0 END) AS MONTH_10_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '11' THEN DAILY_SALE ELSE 0 END) AS MONTH_11_SALES,
SUM(CASE WHEN TO_CHAR(DAY, 'MM') = '12' THEN DAILY_SALE ELSE 0 END) AS MONTH_12_SALES,
SUM(
    CASE
        WHEN TO_CHAR(DAY, 'MM') IN ('10', '11', '12')
        THEN DAILY_SALE
        ELSE 0
    END) AS Q4_SALES,
SUM(
    CASE
        WHEN TO_CHAR(DAY, 'MM') IN ('07', '08', '09')
        THEN DAILY_SALE
        ELSE 0
    END) AS Q3_SALES,
SUM(
    CASE
        WHEN TO_CHAR(DAY, 'MM') IN ('04', '05', '06')
        THEN DAILY_SALE
        ELSE 0
    END) AS Q2_SALES,
SUM(
    CASE
        WHEN TO_CHAR(DAY, 'MM') IN ('01', '02', '03')
        THEN DAILY_SALE
        ELSE 0
    END) AS Q1_SALES,
FROM
SALES_TABLE
GROUP BY
CUSTOMER,
PRODUCT,
EXTRACT(YEAR FROM DAY)
--------------------------------------------------------------------------------------------------------------------------------------
-- rollup and cube and grouping_id

SELECT fact_1_id,
       fact_2_id,
       SUM(sales_value) AS sales_value
FROM   dimension_tab
GROUP BY ROLLUP (fact_1_id, fact_2_id)
ORDER BY fact_1_id, fact_2_id;

 FACT_1_ID  FACT_2_ID SALES_VALUE
---------- ---------- -----------
         1          1     4363.55
         1          2     4794.76
         1          3     4718.25
         1          4     5387.45
         1          5     5027.34
         1               24291.35
         2          1     5652.84
         2          2     4583.02
         2          3     5555.77
         2          4     5936.67
         2          5     4508.74
         2               26237.04
                         50528.39

SELECT fact_1_id,
       fact_2_id,
       SUM(sales_value) AS sales_value
FROM   dimension_tab
GROUP BY CUBE (fact_1_id, fact_2_id)
ORDER BY fact_1_id, fact_2_id;

 FACT_1_ID  FACT_2_ID SALES_VALUE
---------- ---------- -----------
         1          1     4363.55
         1          2     4794.76
         1          3     4718.25
         1          4     5387.45
         1          5     5027.34
         1               24291.35
         2          1     5652.84
         2          2     4583.02
         2          3     5555.77
         2          4     5936.67
         2          5     4508.74
         2               26237.04
                    1    10016.39
                    2     9377.78
                    3    10274.02
                    4    11324.12
                    5     9536.08
                         50528.39

18 rows selected.

SELECT fact_1_id,
       fact_2_id,
       SUM(sales_value) AS sales_value,
       GROUPING(fact_1_id) AS f1g, 
       GROUPING(fact_2_id) AS f2g
FROM   dimension_tab
GROUP BY CUBE (fact_1_id, fact_2_id)
ORDER BY fact_1_id, fact_2_id;

 FACT_1_ID  FACT_2_ID SALES_VALUE        F1G        F2G
---------- ---------- ----------- ---------- ----------
         1          1     4363.55          0          0
         1          2     4794.76          0          0
         1          3     4718.25          0          0
         1          4     5387.45          0          0
         1          5     5027.34          0          0
         1               24291.35          0          1
         2          1     5652.84          0          0
         2          2     4583.02          0          0
         2          3     5555.77          0          0
         2          4     5936.67          0          0
         2          5     4508.74          0          0
         2               26237.04          0          1
                    1    10016.39          1          0
                    2     9377.78          1          0
                    3    10274.02          1          0
                    4    11324.12          1          0
                    5     9536.08          1          0
                         50528.39          1          1

18 rows selected.

SELECT fact_1_id,
       fact_2_id,
       SUM(sales_value) AS sales_value,
       GROUPING_ID(fact_1_id, fact_2_id) AS grouping_id
FROM   dimension_tab
GROUP BY CUBE (fact_1_id, fact_2_id)
ORDER BY fact_1_id, fact_2_id;

 FACT_1_ID  FACT_2_ID SALES_VALUE GROUPING_ID
---------- ---------- ----------- -----------
         1          1     4363.55           0
         1          2     4794.76           0
         1          3     4718.25           0
         1          4     5387.45           0
         1          5     5027.34           0
         1               24291.35           1
         2          1     5652.84           0
         2          2     4583.02           0
         2          3     5555.77           0
         2          4     5936.67           0
         2          5     4508.74           0
         2               26237.04           1
                    1    10016.39           2
                    2     9377.78           2
                    3    10274.02           2
                    4    11324.12           2
                    5     9536.08           2
                         50528.39           3

18 rows selected.

SELECT fact_1_id,
       fact_2_id,
       SUM(sales_value) AS sales_value,
       GROUPING_ID(fact_1_id, fact_2_id) AS grouping_id,
       GROUP_ID() AS group_id
FROM   dimension_tab
GROUP BY GROUPING SETS(fact_1_id, CUBE (fact_1_id, fact_2_id))
HAVING GROUP_ID() = 0
ORDER BY fact_1_id, fact_2_id;

 FACT_1_ID  FACT_2_ID SALES_VALUE GROUPING_ID   GROUP_ID
---------- ---------- ----------- ----------- ----------
         1          1     4363.55           0          0
         1          2     4794.76           0          0
         1          3     4718.25           0          0
         1          4     5387.45           0          0
         1          5     5027.34           0          0
         1               24291.35           1          0
         2          1     5652.84           0          0
         2          2     4583.02           0          0
         2          3     5555.77           0          0
         2          4     5936.67           0          0
         2          5     4508.74           0          0
         2               26237.04           1          0
                    1    10016.39           2          0
                    2     9377.78           2          0
                    3    10274.02           2          0
                    4    11324.12           2          0
                    5     9536.08           2          0
                         50528.39           3          0

18 rows selected.
--------------------------------------------------------------------------------------------------------------------------------------------------- 
Q. Describe TO_DATE function.
A. The TO_DATE function returns a timestamp from a character string that has been interpreted using a character template.TO_DATE is a synonym for TIMESTAMP_FORMAT.
 
Write a syntax for To_Date function 
 
To_date('2003/07/09', 'yyyy/mm/dd') would return a date value of July 9, 2003. 
To_date('070903', 'MMDDYY') would return a date value of July 9, 2003. 
To_date('20020315', 'yyyymmdd') would return a date value of Mar 15, 2002.
 
SELECT TO_DATE('January 15','MONTH DD') "Sample" FROM DUAL

-----------------------------
CREATE TABLE sales([name] NVARCHAR(20) ,
            MONTH NVARCHAR(20) , 
            amount INT )
GO
INSERT INTO sales
SELECT 'ABC', 'Jun-08', 100
UNION ALL SELECT 'XYZ', 'Feb-08', 150
UNION ALL SELECT 'AAA', 'Mar-08', 200
UNION ALL SELECT 'ABC', 'Feb-08', 200
UNION ALL SELECT 'XYZ', 'Mar-08' , 100
UNION ALL SELECT 'ABA', 'Jun-08', 200
UNION ALL SELECT 'ACC', 'Feb-08', 200
UNION ALL SELECT 'XXX', 'Mar-08' , 100

SELECT [name] =COALESCE([name],'Sum'),
       [Jun-08]=SUM(CASE WHEN MONTH='Jun-08' 
                           THEN amount ELSE 0 END),
       [Feb-08]=SUM(CASE WHEN MONTH='Feb-08' 
                           THEN amount ELSE 0 END),
       [Mar-08]=SUM(CASE WHEN MONTH='Mar-08' 
                           THEN amount ELSE 0 END),
       [total]=SUM(amount)
FROM sales GROUP BY [name] WITH ROLLUP
ORDER BY GROUPING([name]),name
/*
result

name                 Jun-08      Feb-08      Mar-08      total
-------------------- ----------- ----------- ----------- -----------
AAA                  0           0           200         200
ABA                  200         0           0           200
ABC                  100         200         0           300
ACC                  0           200         0           200
XXX                  0           0           100         100
XYZ                  0           150         100         250
Sum                  300         550         400         1250