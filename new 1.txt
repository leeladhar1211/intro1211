--Indexes are one of many means of reducing disk I/O.If a heap-organized table has no indexes, then the database must perform a full table scan to find a value.A referential integrity constraint exists on the indexed column or columns. The index is a means to avoid a full table lock that would otherwise be required if you update the parent table primary key, merge into the parent table, or delete from the parent table
--A composite index, also called a concatenated index, is an index on multiple columns in a table.
--Functions that are called from PL/SQL queries, where the functions might be executed millions of times. You will want to look at all performance features to make the function as efficient as possible, and perhaps a function-based index to precompute the results for each row and save on query time.
--Programs that spend a lot of time processing INSERT, UPDATE, or DELETE statements, or looping through query results. You will want to investigate the FORALL statement for issuing DML, and the BULK COLLECT INTO and RETURNING BULK COLLECT INTO clauses for queries.
--Any program that spends a lot of time doing PL/SQL processing, as opposed to issuing DDL statements like CREATE TABLE that are just passed directly to SQL. You will want to investigate native compilation. Because many built-in database features use PL/SQL, you can apply this tuning feature to an entire database to improve performance in many areas, not just your own code.
There are several proven techniques for improving the speed of PL/SQL execution and they are presented below in order of importance:

Use bulk collect: When reading-in lots of related rows, bulk collect can run 10x faster than a conventional loop. This tuning is possible because Oracle reduces context switches into a single operation.

Use forall: When loading a table from an array, the forall operator is 10x faster than a conventional SQL insert statement. Again, this is because of the reduction of context switching.

Use SQL analytics: Many advanced data operations can be done without using PL/SQL and are readily available as a SQL built-in function.

Use implicit cursors: Implicit cursors are faster in PL/SQL than explicitly defining cursors

explain plan: EXPLAIN PLAN parses a query and records the "plan" that Oracle devises to execute it. By examining this plan, you can find out if Oracle is picking the right indexes and joining your tables in the most efficient manner. There are a few different ways to utilize Explain Plan. We will focus on using it 
SQL> EXPLAIN PLAN FOR select * from dept where deptno = 40;
Explained.
SQL> set linesize 132
SQL> SELECT * FROM TABLE(dbms_xplan.display);
PLAN_TABLE_OUTPUT
---------------------------------------------------------------------------------------
Plan hash value: 2852011669
---------------------------------------------------------------------------------------
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |
---------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT | | 1 | 20 | 1 (0)| 00:00:01 |
| 1 | TABLE ACCESS BY INDEX ROWID| DEPT | 1 | 20 | 1 (0)| 00:00:01 |
|* 2 | INDEX UNIQUE SCAN | PK_DEPT | 1 | | 0 (0)| 00:00:01 |
------------------------------------------------------------------

SQL*Plus also offers an AUTOTRACE facility that will display the query plan and execution statistics as each query executes. Example:

SQL> SET AUTOTRACE ON
SQL> select * from dept where deptno = 40;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        40 OPERATIONS     BOSTON

Execution Plan
----------------------------------------------------------
Plan hash value: 2852011669


---------------------------------------------------------------------------------------
| Id  | Operation                   | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |         |     1 |    20 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| DEPT    |     1 |    20 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_DEPT |     1 |       |     0   (0)| 00:00:01 |
---------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("DEPTNO"=40)

Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          2  consistent gets
          0  physical reads
          0  redo size
        443  bytes sent via SQL*Net to client
        374  bytes received via SQL*Net from client
          1  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed

Database Indexes
A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of slower writes and increased storage space.By default, Oracle creates B-tree indexes.

Types of Index

A)Clustered Index
B)Non Clustered Index

Clustered Index:- Clustering alters the data block into a certain distinct order to match the index, resulting in the row data being stored in order. Therefore, only one clustered index can be created on a given database table.
Typically created on primary key column.

Non Clustered Index:-The data is present in random order, but the logical ordering is specified by the index. The data rows may be randomly spread throughout the table. The non-clustered index tree contains the index keys in sorted order, with the leaf level of the index containing the pointer to the page and the row number in the data page
The physical order of the rows is not the same as the index order.
Typically created on column used in JOIN, WHERE, and ORDER BY clauses.

Difference between Clustered and non Clustered Index:-

1)Clustered indices can greatly increase overall speed of retrieval, but usually only where the data is accessed sequentially in the same or reverse order of the clustered index, or when a range of items is selected.Non Clustered index is Good for tables whose values may be modified frequently.
2) Clustered index usually saved in side the table however non Clustered Index saved in separate tables in database.

There are multiple ways to implement Index:-

1)Bitmap Index:-A bitmap index is a special kind of index that stores the bulk of its data as bitmaps and answers most queries by performing bitwise logical operations on these bitmaps. The most commonly used index, such as B+tree are most efficient if the values it indexes do not repeat or repeat a smaller number of times

2)B-tree Index:-By default, the Oracle creates a b_tree index.  In a b-tree, you walk the branches until you get to the node that has the data you want to use.  In the classic b-tree structure, there are branches from the top that lead to leaf nodes that contain the data.

3)Dense Index:- A dense index in database is a file with pairs of keys and pointers for every record  in the data file. Every key in this file is associated with a particular pointer to a record in the sorted data file. In clustered indices with duplicate keys, the dense index points to the first record with that key.

4)Sparse Index:-A sparse index in databases is a file with pairs of keys and pointers for every block in the data file. Every key in this file is associated with a particular pointer to the block in the sorted data file. In clustered indices with duplicate keys, the sparse index points to the lowest search key in each block. primary key is a sparse index.

5)Reverse Index:- reverse key index reverses the key value before entering it in the index. E.g., the value 24538 becomes 83542 in the index. Reversing the key value is particularly useful for indexing data such as sequence numbers, where new key values monotonically increase.

6)Function based Index:- An index is defined on the result of a function applied to one or more columns of a single table. Functional indexes can be used to obtain fast access to data based on the result of function calls.
Ex:-This query can use an index, if one has been defined on the result of the lower(coll) operation:

CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
 
The function in the index definition can take more than one argument, but they must be table columns, not constants. Functional indexes are always single-column (namely, the function result) even if the function uses more than one input field; there cannot be multi column indexes that contain function calls.

Advantage of Index:- 
Faster retrieval of data. Increased performance.There is no need to access a row in the database from an index structure, so you can reduce the total number of I/O operations needed to retrieve data.
Presorted data-The data in the leaf nodes is already sorted by the value of the primary key. 
Disadvantages of Index:-
You must have a primary key on the table with a unique value.
You cannot have any other indexes on the data.
You cannot partition an index-organized table.
An index-organized table cannot be a part of a cluster.

Bitmap Index vs. B-tree Index: Which and When?

http://oracle.readthedocs.io/en/latest/sql/plans/explain-plan.html?highlight=explain%20plan
http://oracle.readthedocs.io/en/latest/sql/plans/explain-plan.html
http://www.oracle.com/technetwork/articles/sharma-indexes-093638.html
https://docs.oracle.com/cd/B14117_01/appdev.101/b10795/adfns_in.htm
http://www.dba-oracle.com/art_9i_indexing.htm
https://www.red-gate.com/simple-talk/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/
https://blogs.oracle.com/sql/how-to-create-and-use-indexes-in-oracle-database
https://docs.oracle.com/cloud/latest/db112/CNCPT/indexiot.htm#CNCPT1895
https://www.quora.com/What-are-the-frequent-interview-questions-on-Oracle-indexes
https://tekslate.com/oracle-performance-tuning-interview-questions-and-answers